# 12.基于规则的优化

条件化简
移除不必要的括号
常量传递（constant_propagation）
等值传递（equality_propagation）
移除没用的条件（trivial_condition_removal）
表达式计算
HAVING子句和WHERE子句的合并
常量表检测
外连接消除（指定的WHERE子句中包含被驱动表中的列不为NULL值的条件称之为空值拒绝）
按返回的结果集区分子查询
标量子查询：那些只返回一个单一值的子查询称之为标量子查询，比如：
SELECT (SELECT m1 FROM t1 LIMIT 1);
行子查询：顾名思义，就是返回一条记录的子查询，不过这条记录需要包含多个列（只包含一个列就成了标量子查询了）。比如这样：
SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);
列子查询：列子查询自然就是查询出一个列的数据喽，不过这个列的数据需要包含多条记录（只包含一条记录就成了标量子查询了）。比如这样：
SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
表子查询：顾名思义，就是子查询的结果既包含很多条记录，又包含很多个列，比如这样：
SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);
按与外层查询关系来区分子查询
不相关子查询：如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为不相关子查询。我们前边介绍的那些子查询全部都可以看作不相关子查询，所以也就不举例子了哈。
相关子查询：如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为相关子查询。比如：
SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);

子查询语法注意事项
子查询必须用小括号扩起来。
在SELECT子句中的子查询必须是标量子查询。
在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用LIMIT 1语句来限制记录数量。
对于[NOT] IN/ANY/SOME/ALL子查询来说，子查询中不允许有LIMIT语句
不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。
IN子查询优化
对于使用关键字'IN'查询来说，如果子查询的结果集太多，那就意味着IN子句中的参数特别多，这就导致：
无法有效的使用索引，只能对外层查询进行全表扫描。
在对外层查询执行全表扫描时，由于IN子句中的参数太多，这会导致检测一条记录是否符合和IN子句中的参数匹配花费的时间太长。
物化表的提出：不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表里。写入临时表的过程是这样的：
该临时表的列就是子查询结果集中的列。
写入临时表的记录会被去重。
一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用Memory存储引擎的临时表，而且会为该表建立哈希索引。
如果子查询的结果集非常大，超过了系统变量tmp_table_size或者max_heap_table_size，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为B+树索引
物化表转连接: 通过子查询建立的物化表把原来的查询可以转化为连接查询
将子查询转换为semi-join（半连接）：不需要物化直接将子查询变成连接查询
什么是semi-join？
所谓的semi-join是指semi-join子查询。 当一张表在另一张表找到匹配的记录之后，半连接（semi-jion）返回第一张表中的记录。与条件连接相反，即使在右节点中找到几条匹配的记录，左节点 的表也只会返回一条记录。另外，右节点的表一条记录也不会返回。半连接通常使用IN  或 EXISTS 作为连接条件。 该子查询具有如下结构：
SELECT ... FROM outer_tables WHERE expr IN (SELECT ... FROM inner_tables ...) AND ...
即在where条件的“IN”中的那个子查询。
这种查询的特点是我们只关心outer_table中与semi-join相匹配的记录。
换句话说，最后的结果集是在outer_tables中的，而semi-join的作用只是对outer_tables中的记录进行筛选。这也是我们进行
semi-join优化的基础，即我们只需要从semi-join中获取到最少量的足以对outer_tables记录进行筛选的信息就足够了。
实现这种所谓的半连接：
Table pullout （子查询中的表上拉）
DuplicateWeedout execution strategy （重复值消除）
LooseScan execution strategy （松散扫描）
Semi-join Materialization execution strategy
FirstMatch execution strategy （首次匹配）
符合下边这些条件的子查询才可以被转换为semi-join：
该子查询必须是和IN语句组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现。
外层查询也可以有其他的搜索条件，只不过和IN子查询的搜索条件必须使用AND连接起来。
该子查询必须是一个单一的查询，不能是由若干查询由UNION连接起来的形式。
如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：
先将子查询物化之后再执行查询
执行IN to EXISTS转换。
ANY/ALL子查询优化
[NOT] EXISTS子查询的执行
对于派生表的优化
最容易想到的就是把派生表物化。
将派生表和外层的表合并，也就是将查询重写为没有派生表的形式

# 13.Explain关键字

一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。设计MySQL的大叔贴心的为我们提供了EXPLAIN语句来帮助我们查看某个查询语句的具体执行计划
EXPLAIN语句输出的各个列的作用先大致罗列一下：
列名 描述
id 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id
select_type SELECT关键字对应的那个查询的类型
table 表名
partitions 匹配的分区信息
type 针对单表的访问方法
possible_keys 可能用到的索引
key 实际上使用的索引
key_len 实际使用到的索引长度
ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息
rows 预估的需要读取的记录条数
filtered 某个表经过搜索条件过滤后剩余记录条数的百分比
Extra 一些额外的信息

# 14.Optimize Trace

设计MySQL的大叔可能会在之后的版本中添加更多的优化过程信息。不过杂乱之中其实还是蛮有规律的，优化过程大致分为了三个阶段：
prepare阶段
optimize阶段
execute阶段
我们所说的基于成本的优化主要集中在optimize阶段，对于单表查询来说，我们主要关注optimize阶段的"rows_estimation"这个过程，这个过程深入分析了对单表查询的各种执行方案的成本；对于多表连接查询来说，我们更多需要关注"considered_execution_plans"这个过程，这个过程里会写明各种不同的连接方式所对应的成本。反正优化器最终会选择成本最低的那种方案来作为最终的执行计划，也就是我们使用EXPLAIN语句所展现出的那种方案。
如果有小伙伴对使用EXPLAIN语句展示出的对某个查询的执行计划很不理解，大家可以尝试使用optimizer trace功能来详细了解每一种执行方案对应的成本，相信这个功能能让大家更深入的了解MySQL查询优化器。